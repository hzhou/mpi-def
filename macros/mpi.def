include: c/mpi_info.def

subcode: mpi_frame
    $include stdio
    $include stdlib
    $call @global
    $function main
        &call mpi_run
            $call main

subcode: _autoload
    $register_name(status) MPI_Status
    $register_prefix(comm) MPI_Comm
    $register_prefix(info) MPI_Info
    $register_prefix(req) MPI_Request

macros:
    mpi: 1
    tag: 0
    comm: MPI_COMM_WORLD

    mpi_n1: MPI_BYTE
    mpi_n2: MPI_SHORT
    mpi_n4: MPI_INT
    mpi_n8: MPI_2INT
    mpi_f4: MPI_FLOAT
    mpi_f8: MPI_DOUBLE
    mpi_c16: MPI_LONG_DOUBLE

subcode: mpi_run
    $(if:!SKIP_SYSTEM_MPI)
        $include mpi
        $uselib mpi

    $global int mpi_size, int mpi_id
    MPI_Init(NULL, NULL)
    MPI_Comm_size($(comm), &mpi_size)
    MPI_Comm_rank($(comm), &mpi_id)

    $(if:0)
        $global char mpi_name[MPI_MAX_PROCESSOR_NAME]
        $local tn_len
        MPI_Get_processor_name(mpi_name, &tn_len)

    BLOCK

    $call @on_mpi_finalize
    MPI_Finalize()

#----------------------------------------
subcode: _autoload
    $plugin mpicall

# overwrite subcode mpicall to change the default error behavior
subcode:0 mpicall(fname, @params)
    $(fname)($(params))

#---------------------------------------- 
subcode: with_p2p(p1, p2)
    $if mpi_id == $(p1)
        $(set:is_p1=1)
        BLOCK
    $elif mpi_id == $(p2)
        $(set:is_p2=1)
        BLOCK

    # ---- example ----
    subcode: send_to(@data)
        &call parse_data
            $(if:is_p1)
                $call _send, $(p2)
            $(else)
                $call _recv, $(p1)

    subcode: send_back(@data)
        &call parse_data
            $(if:is_p1)
                $call _recv, $(p2)
            $(else)
                $call _send, $(p1)

    subcode: exchange(local, remote, size)
        $(set:data_src=$(local), $(size), MPI_BYTE)
        $(set:data_dst=$(remote), $(size), MPI_BYTE)
        $(if:is_p1)
            $call _send, $(p2)
            $call _recv, $(p2)
        $(else)
            $call _recv, $(p1)
            $call _send, $(p1)

    # ---- isend/irecv ----
    subcode: isend_to(@data)
        &call parse_data
            $(if:is_p1)
                $call _isend, $(p2)
            $(else)
                $call _irecv, $(p1)

    subcode: isend_back(@data)
        &call parse_data
            $(if:is_p1)
                $call _irecv, $(p2)
            $(else)
                $call _isend, $(p1)

    subcode: iexchange(local, remote, size)
        $(set:data_src=$(local), $(size), MPI_BYTE)
        $(set:data_dst=$(remote), $(size), MPI_BYTE)
        $(if:is_p1)
            $call _isend, $(p2)
            $call _irecv, $(p2)
        $(else)
            $call _irecv, $(p1)
            $call _isend, $(p1)

subcode: ifelse_region(p0)
    $if mpi_id == $(p0)
        $(set:is_p1=1)
        BLOCK
    $else
        $(set:is_p2=1)
        BLOCK

subcode: ring_region
    # left and right
    $if mpi_id == 0
        $(set:is_first=1)
        $(set:_l=mpi_size-1)
        $(set:_r=1)
        BLOCK
    $elif mpi_id==mpi_size-1
        $(set:is_last=1)
        $(set:_l=mpi_id-1)
        $(set:_r=0)
        BLOCK
    $else
        $(set:is_middle=1)
        $(set:_l=mpi_id-1)
        $(set:_r=mpi_id+1)
        BLOCK

#---- shorthand ---------------------------------- 
subcode: parse_data
    $(split:data)
    $(if:p_n=3)
        #- buf, count, type
        $(set:data_src=$(data))
        $(set:data_dst=$(data))
    $(elif:p_n=4)
        #- src_buf, dst_buf, count, type
        $(set:data_src=$(p_1),$(p_3),$(p_4))
        $(set:data_dst=$(p_2),$(p_3),$(p_4))
    BLOCK

subcode: _send(to)
    tn_ret = MPI_Send($(data_src), $(to), $(tag), $(comm))
subcode: _isend(to)
    tn_ret = MPI_Isend($(data_src), $(to), $(tag), $(comm), &$(req))

subcode: _recv(from)
    tn_ret = MPI_Recv($(data_dst), $(from), $(tag), $(comm), MPI_STATUS_IGNORE)
subcode: _irecv(from)
    tn_ret = MPI_Irecv($(data_dst), $(from), $(tag), $(comm), &$(req))

#---- pt2pt -------------------:------- 
# define data as $(buf), $(type), $(size)
subcode: mpi_send(from, to)
    ...
    $if mpi_id == $(from)
        DUMP_STUB send...
        tn_ret = MPI_Send($(data), $(to), $(tag), $(comm))
    $elif mpi_id == $(to)
        tn_ret = MPI_Recv($(data), $(from), $(tag), $(comm), MPI_STATUS_IGNORE)
        DUMP_STUB recv...
    BLOCK

subcode: mpi_isend(from, to)
    $local MPI_Request req, MPI_Status status
    ...
    $if mpi_id == $(from)
        DUMP_STUB send...
        tn_ret = MPI_Isend($(data), $(to), $(tag), $(comm), &req)
        DUMP_STUB sending...
        tn_ret = MPI_Wait(&req, &status)
    $elif mpi_id == $(to)
        tn_ret = MPI_Irecv($(data), $(from), $(tag), $(comm), &req)
        DUMP_STUB recving...
        tn_ret = MPI_Wait(&req, &status)
        DUMP_STUB recv...
    BLOCK

#---- collectives ----------------------------------- 
subcode: mpi_barrier
    MPI_Barrier($(comm))

subcode: mpi_bcast
    MPI_Bcast($(data), 0, $(comm))

subcode: mpi_scatter(global, local, type)
    MPI_Scatterv($(global), pn_mpi_size, pn_mpi_offs, $(type), $(local), pn_mpi_size[mpi_id], $(type), 0, $(comm))

subcode: mpi_gather(global, local, type)
    MPI_Gatherv($(local), pn_mpi_size[mpi_id], $(type), $(global), pn_mpi_size, pn_mpi_offs, $(type), 0, $(comm))

#---- onesided ---------------------------- 
#- implicit: $(data), $(win)
subcode: _autoload
    $register_name(win) MPI_Win

subcode: mpi_win_allocate(size)
    $global MPI_Win win, void *mpi_base
    MPI_Win_allocate($(size), 1, MPI_INFO_NULL, $(comm), &mpi_base, &win)
    $(setmacro:win=win)

subcode: mpi_put(tgt, offset)
    $(split:data)
    MPI_Win_lock(MPI_LOCK_EXCLUSIVE, $(tgt), 0, $(win))
    MPI_Put($(data), $(tgt), $(offset), $(p_2), $(p_3), $(win))
    MPI_Win_unlock($(tgt), $(win))

subcode:: on_mpi_finalize
    $(if:win=win)
        MPI_Win_free(&$(win))

#---- convenience ---------------------------- 
subcode: hello
    $print Hello from $mpi_name, $mpi_id/$mpi_size

#---- app: distribute --------------------------- 
subcode: mpi_distribute(N)
    $(setmacro:mpi_distribute=1)
    $global n_mpi_N
    $global pn_mpi_offs = NULL, pn_mpi_size = NULL
    $if pn_mpi_offs == NULL
        $allocate(mpi_size+1) pn_mpi_offs, pn_mpi_size
    n_mpi_N = $(N)
    tn_per = $(N)/mpi_size
    tn_remain = $(N) % mpi_size
    j = 0
    $for i=0:mpi_size
        pn_mpi_offs[i] = j
        $if i<tn_remain
            pn_mpi_size[i] = tn_per + 1
        $else
            pn_mpi_size[i] = tn_per
        j+=pn_mpi_size[i]
    pn_mpi_offs[mpi_size] = $(N)

subcode:: on_mpi_finalize
    $(if:mpi_distribute)
        $if pn_mpi_offs
            free(pn_mpi_offs)
            free(pn_mpi_size)

#--------------------------------------------- 
subcode: debug_hook(cond)
    $include unistd
    $if $(cond)
        $print "mpi [$mpi_id] PID %d is ready for attach ...", getpid()
        $local int debug_i=0
        $while debug_i == 0
            sleep(5)
