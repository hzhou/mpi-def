subcode: mpi_frame
    $include stdio
    $include stdlib
    $call @global
    $function main
        &call mpi_run
            $call main

subcode: _autoload
    $register_name(win) MPI_Win
    $register_name(status) MPI_Status
    $register_prefix(comm) MPI_Comm
    $register_prefix(info) MPI_Info
    $register_prefix(req) MPI_Request

macros:
    mpi: 1
    tag: 0
    comm: MPI_COMM_WORLD

    mpi_n1: MPI_BYTE
    mpi_n2: MPI_SHORT
    mpi_n4: MPI_INT
    mpi_n8: MPI_2INT
    mpi_f4: MPI_FLOAT
    mpi_f8: MPI_DOUBLE
    mpi_c16: MPI_LONG_DOUBLE

subcode: mpi_run
    $include mpi
    $uselib mpi

    $global int mpi_size, int mpi_id, is_mpi_main
    MPI_Init(NULL, NULL);
    MPI_Comm_size($(comm), &mpi_size);
    MPI_Comm_rank($(comm), &mpi_id);
    $if mpi_id==0
        is_mpi_main = 1
    $else
        is_mpi_main = 0

    $global char mpi_name[MPI_MAX_PROCESSOR_NAME]
    $local tn_len
    MPI_Get_processor_name(mpi_name, &tn_len);

    BLOCK

    MPI_Finalize();
    $(if:mpi_distribute)
        $if pn_mpi_offs
            free(pn_mpi_offs)
            free(pn_mpi_size)

subcode: mpi_distribute(N)
    $(setmacro:mpi_distribute=1)
    $global n_mpi_N
    $global pn_mpi_offs = NULL, pn_mpi_size = NULL
    $if pn_mpi_offs == NULL
        $allocate(mpi_size+1) pn_mpi_offs, pn_mpi_size
    n_mpi_N = $(N)
    tn_per = $(N)/mpi_size
    tn_remain = $(N) % mpi_size
    j = 0
    $for i=0:mpi_size
        pn_mpi_offs[i] = j
        $if i<tn_remain
            pn_mpi_size[i] = tn_per + 1
        $else
            pn_mpi_size[i] = tn_per
        j+=pn_mpi_size[i]
    pn_mpi_offs[mpi_size] = $(N)

#---------------------------------------- 
subcode: p2p_region(p1, p2)
    $if mpi_id == $(p1)
        $(set:is_main=1)
        BLOCK
    $elif mpi_id == $(p2)
        BLOCK

    subcode: p2p(a1, a2)
        $(if:is_main)
            $call $(a1), $(p2)
        $(else)
            $call $(a2), $(p1)

    # ---- example ----
    subcode: send_to(@data)
        $call p2p, _send, _recv

    subcode: send_back(@data)
        $call p2p, _recv, _send


subcode: ifelse_region(p0)
    $if mpi_id == $(p0)
        $(set:is_main=1)
        BLOCK
    $else
        BLOCK

subcode: ring_region
    # left and right
    $if mpi_id == 0
        $(set:is_main=1)
        $(set:_l=mpi_size-1)
        $(set:_r=1)
        BLOCK
    $elif mpi_id==mpi_size-1
        $(set:_l=mpi_id-1)
        $(set:_r=0)
        BLOCK
    $else
        $(set:_l=mpi_id-1)
        $(set:_r=mpi_id+1)
        BLOCK

#---- Point to Point -------------------:------- 
# define data as $(buf), $(type), $(size)

subcode: mpi_send(from, to)
    ...
    $if mpi_id == $(from)
        DUMP_STUB send...
        tn_ret = MPI_Send($(data), $(to), $(tag), $(comm))
    $elif mpi_id == $(to)
        tn_ret = MPI_Recv($(data), $(from), $(tag), $(comm), MPI_STATUS_IGNORE)
        DUMP_STUB recv...
    BLOCK

subcode: mpi_isend(from, to)
    $local MPI_Request req, MPI_Status status
    ...
    $if mpi_id == $(from)
        DUMP_STUB send...
        tn_ret = MPI_Isend($(data), $(to), $(tag), $(comm), &req)
        DUMP_STUB sending...
        tn_ret = MPI_Wait(&req, &status)
    $elif mpi_id == $(to)
        tn_ret = MPI_Irecv($(data), $(from), $(tag), $(comm), &req)
        DUMP_STUB recving...
        tn_ret = MPI_Wait(&req, &status)
        DUMP_STUB recv...
    BLOCK

#---- shorthand ---------------------------------- 
subcode: _send(to)
    tn_ret = MPI_Send($(data), $(to), $(tag), $(comm))
subcode: _isend(to)
    tn_ret = MPI_Isend($(data), $(to), $(tag), $(comm), $(req))

subcode: _recv(from)
    tn_ret = MPI_Recv($(data), $(from), $(tag), $(comm), MPI_STATUS_IGNORE)
subcode: _irecv(from)
    tn_ret = MPI_Irecv($(data), $(from), $(tag), $(comm), $(req))

#----------------------------------------------- 
subcode: mpi_sync(v, type)
    MPI_Bcast(&$(v), 1, $(type), 0, $(comm))

subcode: mpi_cast(v, type, count)
    $if !is_mpi_main
        $allocate($(count)) $(v)
    MPI_Bcast($(v), $(count), $(type), 0, $(comm))

subcode: mpi_scatter(global, local, type)
    MPI_Scatterv($(global), pn_mpi_size, pn_mpi_offs, $(type), $(local), pn_mpi_size[mpi_id], $(type), 0, $(comm))

subcode: mpi_gather(global, local, type)
    MPI_Gatherv($(local), pn_mpi_size[mpi_id], $(type), $(global), pn_mpi_size, pn_mpi_offs, $(type), 0, $(comm))

#---- convenience ---------------------------- 
subcode: hello
    $print Hello from $mpi_name, $mpi_id/$mpi_size

#--------------------------------------------- 
subcode: debug_hook(cond)
    $include unistd
    $if $(cond)
        $print "mpi [$mpi_id] PID %d is ready for attach ...", getpid()
        $local int debug_i=0
        $while debug_i == 0
            sleep(5)
